#!/usr/bin/env perl

use strict;
use warnings;

use Getopt::Long qw(GetOptionsFromArray);
use Pod::Usage;
use DBI;
use Devel::StackTrace;
use Data::Dumper;

use constant ZABBIX_SERVER_CONF_FILE => '/etc/zabbix/zabbix_server.conf';

use constant EXTERNAL_NOTIFICATION_SCRIPT => '/opt/zabbix/alertscripts/script.py';

use constant EVENT_SOURCE_TRIGGERS  => 0; # event was generated by a trigger status change
use constant EVENT_OBJECT_TRIGGER   => 0; # trigger
use constant TRIGGER_VALUE_FALSE    => 0; # trigger changed state to OK
use constant TRIGGER_VALUE_TRUE     => 1; # trigger changed state to PROBLEM
use constant ITEM_VALUE_TYPE_FLOAT  => 0; # float
use constant ITEM_VALUE_TYPE_UINT64 => 3; # unsigned integer

################################################################################
# main
################################################################################

sub main()
{
	parse_opts();

	if (!opt('event-id'))
	{
		usage("--event-id is missing", 1);
	}

	if (opt('debug'))
	{
		log_debug_messages(1);
		dbg("command line: %s %s", $0, join(' ', map(index($_, ' ') == -1 ? $_ : "'$_'", @ARGV)));
	}

	my $event_id = getopt('event-id');

	db_connect();

	my $rows;

	$rows = db_select("
		select
			events.source,
			events.object,
			events.objectid,
			events.clock,
			events.ns,
			events.value,
			triggers.description
		from
			events
			left join triggers on triggers.triggerid = events.objectid
		where
			events.eventid=?
	", [getopt('event-id')]);


	fail("event not found") if (@{$rows} == 0);
	fail("multiple events found") if (@{$rows} > 1);

	my ($event_source, $event_object, $trigger_id, $event_clock, $event_ns, $event_value, $description) = @{$rows->[0]};

	fail("unexpected event source") if ($event_source != EVENT_SOURCE_TRIGGERS);
	fail("unexpected event object") if ($event_object != EVENT_OBJECT_TRIGGER);
	fail("unexpected event value") if ($event_value != TRIGGER_VALUE_FALSE && $event_value != TRIGGER_VALUE_TRUE);

	$rows = db_select("select distinct itemid from functions where triggerid=?", [$trigger_id]);

	fail("itemid not found in trigger functions") if (@{$rows} == 0);
	fail("multiple itemids found in trigger functions") if (@{$rows} > 1);

	$rows = db_select("
		select
			items.itemid,
			items.key_,
			items.name,
			hosts.hostid,
			hosts.name
		from
			items
			left join hosts on hosts.hostid = items.hostid
		where
			items.itemid=?
	", [$rows->[0][0]]);

	my ($item_id, $item_key, $item_name, $host_id, $host_name) = @{$rows->[0]};

	dbg("event_clock = %s", $event_clock // 'UNDEF');
	dbg("event_value = %s", $event_value // 'UNDEF');
	dbg("description = %s", $description // 'UNDEF'); # e.g., "exceeded 10% of allowed", for extracting percentage
	dbg("item_key    = %s", $item_key    // 'UNDEF'); # to find out what type of trigger it is
	dbg("item_name   = %s", $item_name   // 'UNDEF'); # for old-style triggers, "tld#{TRIGGER.STATUS}#{HOST.NAME1}#{ITEM.NAME1}#{ITEM.VALUE1}"
	dbg("host_id     = %s", $host_id     // 'UNDEF');
	dbg("host_name   = %s", $host_name   // 'UNDEF');

	my $data;

	if ($item_key eq 'rsm.slv.dns.downtime')
	{
		$data = [
			'SLR_CURRENT_MONTH_DNS_service_availability',
			get_history('history_uint', $item_id, $event_clock, $event_ns),
		];
	}
	elsif ($item_key =~ /^rsm.slv.dns.ns.downtime\[(.+),(.*)\]$/)
	{
		my $ns = $1;
		my $ip = $2;

		$data = [
			'SLR_CURRENT_MONTH_NS_availability',
			$ns,
			$ip,
			$description =~ /(?:^|\s)(\d+%)(?:\s|$)/g, # percentage
			get_history('history_uint', $item_id, $event_clock, $event_ns),
		];
	}
	elsif ($item_key eq 'rsm.slv.rdds.downtime')
	{
		$data = [
			'SLR_CURRENT_MONTH_RDDS_service_availability',
			$description =~ /(?:^|\s)(\d+%)(?:\s|$)/g, # percentage
			get_history('history_uint', $item_id, $event_clock, $event_ns),
		];
	}
	elsif ($item_key eq 'rsm.slv.dns.udp.rtt.pfailed')
	{
		$data = [
			'SLR_CURRENT_MONTH_DNS_UDP_RTT_availability',
			$description =~ /(?:^|\s)(\d+%)(?:\s|$)/g, # percentage
			get_history('history_uint', get_item_id($host_id, 'rsm.slv.dns.udp.rtt.performed'), $event_clock, $event_ns),
			get_history('history_uint', get_item_id($host_id, 'rsm.slv.dns.udp.rtt.failed'), $event_clock, $event_ns),
		];
	}
	elsif ($item_key eq 'rsm.slv.dns.tcp.rtt.pfailed')
	{
		$data = [
			'SLR_CURRENT_MONTH_DNS_TCP_RTT_availability',
			$description =~ /(?:^|\s)(\d+%)(?:\s|$)/g, # percentage
			get_history('history_uint', get_item_id($host_id, 'rsm.slv.dns.tcp.rtt.performed'), $event_clock, $event_ns),
			get_history('history_uint', get_item_id($host_id, 'rsm.slv.dns.tcp.rtt.failed'), $event_clock, $event_ns),
		];
	}
	elsif ($item_key eq 'rsm.slv.rdds.rtt.pfailed')
	{
		$data = [
			'SLR_CURRENT_MONTH_RDDS_RTT_service_availability',
			$description =~ /(?:^|\s)(\d+%)(?:\s|$)/g, # percentage
			get_history('history_uint', get_item_id($host_id, 'rsm.slv.rdds.rtt.performed'), $event_clock, $event_ns),
			get_history('history_uint', get_item_id($host_id, 'rsm.slv.rdds.rtt.failed'), $event_clock, $event_ns),
		];
	}
	else
	{
		my $item_value_type = db_select_value("select value_type from items where itemid=?", [$item_id]);

		my $history_table = {
			ITEM_VALUE_TYPE_FLOAT , 'history',
			ITEM_VALUE_TYPE_UINT64, 'history_uint',
		}->{$item_value_type};

		$data = [
			$item_name,
			get_history($history_table, $item_id, $event_clock, $event_ns),
		];
	}

	notify($event_value, $event_clock, $host_name, $data);

	db_disconnect();
}

sub get_history()
{
	my $table   = shift;
	my $item_id = shift;
	my $clock   = shift;
	my $ns      = shift;

	my $query = "select value from $table where itemid=? and clock=? and ns=?";
	my $params = [$item_id, $clock, $ns];

	return db_select_value($query, $params);
}

sub get_item_id($$)
{
	my $host_id  = shift;
	my $item_key = shift;

	my $query = "select itemid from items where hostid=? and key_=?";
	my $params = [$host_id, $item_key];

	return db_select_value($query, $params);
}

sub notify($$$$)
{
	my $event_value = shift;
	my $event_clock = shift;
	my $host_name   = shift;
	my $data        = shift;

	my $event_value_str = {
		TRIGGER_VALUE_FALSE, 'OK',
		TRIGGER_VALUE_TRUE , 'PROBLEM',
	}->{$event_value};

	my ($sec, $min, $hour, $mday, $mon, $year) = localtime($event_clock);
	my $event_clock_str = sprintf("%.4d.%.2d.%.2d %.2d:%.2d:%.2d UTC", $year + 1900, $mon + 1, $mday, $hour, $min, $sec);

	my @args = (
		"zabbix alert",
		join('#', ('tld', $event_value_str, $host_name, @{$data})),
		$event_clock_str,
	);

	@args = map('"' . $_ . '"', @args);

	my $cmd = EXTERNAL_NOTIFICATION_SCRIPT;

	info("executing $cmd @args");
	my $out = qx($cmd @args 2>&1);

	if ($out)
	{
		info("output of $cmd:\n" . $out);
	}

	if ($? == -1)
	{
		fail("failed to execute $cmd: $!");
	}
	if ($? != 0)
	{
		fail("command $cmd exited with value " . ($? >> 8));
	}
}

################################################################################
# output
################################################################################

use constant LOG_LEVEL_DEBUG   => 1;
use constant LOG_LEVEL_INFO    => 2;
use constant LOG_LEVEL_WARNING => 3;
use constant LOG_LEVEL_FAILURE => 4;

my $log_time_str;
my $log_time = 0;

my $log_debug_messages = 0;

$SIG{__WARN__} = sub
{
	local *__ANON__ = 'perl-warn';
	__log(LOG_LEVEL_WARNING, $_[0] =~ s/(\r?\n)+$//r);
};

$SIG{__DIE__} = sub
{
	local *__ANON__ = 'perl-die';
	__log(LOG_LEVEL_FAILURE, $_[0] =~ s/(\r?\n)+$//r);
	db_disconnect() if (is_db_connected());
	exit(255); # Perl's default exit code on die()
};

sub dbg
{
	__log(LOG_LEVEL_DEBUG, @_) if ($log_debug_messages);
}

sub info
{
	__log(LOG_LEVEL_INFO, @_);
}

sub wrn
{
	__log(LOG_LEVEL_WARNING, @_);
}

sub fail
{
	__log(LOG_LEVEL_FAILURE, @_);
	db_disconnect() if (is_db_connected());
	exit(1);
}

sub log_debug_messages(;$)
{
	my $log_debug_messages_tmp = $log_debug_messages;
	if (@_)
	{
		$log_debug_messages = shift;
	}
	return $log_debug_messages_tmp;
}

sub __log
{
	my $message_log_level = shift;
	my $message = (@_ == 1 ? shift : sprintf(shift, @_)) . "\n";

	if ($message_log_level != LOG_LEVEL_DEBUG && $message_log_level != LOG_LEVEL_INFO)
	{
		# 'skip_frames' => 1 removes call to the __log() from the stack trace
		$message .= Devel::StackTrace->new('skip_frames' => 1, 'indent' => 1)->as_string() =~ s/^\t/> /mgr;
	}

	my $log_time_tmp = time();
	if ($log_time != $log_time_tmp)
	{
		my ($sec, $min, $hour, $mday, $mon, $year) = localtime($log_time_tmp);
		$log_time_str = sprintf("%.4d%.2d%.2d:%.2d%.2d%.2d", $year + 1900, $mon + 1, $mday, $hour, $min, $sec);
		$log_time = $log_time_tmp;
	}

	my $log_level_str;
	$log_level_str = 'DBG' if ($message_log_level == LOG_LEVEL_DEBUG);
	$log_level_str = 'INF' if ($message_log_level == LOG_LEVEL_INFO);
	$log_level_str = 'WRN' if ($message_log_level == LOG_LEVEL_WARNING);
	$log_level_str = 'ERR' if ($message_log_level == LOG_LEVEL_FAILURE);

	my $caller = (caller(2))[3] // "";
	if ($caller)
	{
		$caller = " " . ($caller =~ s/^.*:://r) . "()";
	}

	my $message_prefix = sprintf("%6d:%s [%s]%s", $$, $log_time_str, $log_level_str, $caller);

	my $output_handle;
	$output_handle = *STDOUT if ($message_log_level == LOG_LEVEL_DEBUG);
	$output_handle = *STDOUT if ($message_log_level == LOG_LEVEL_INFO);
	$output_handle = *STDERR if ($message_log_level == LOG_LEVEL_WARNING);
	$output_handle = *STDERR if ($message_log_level == LOG_LEVEL_FAILURE);

	print($output_handle $message =~ s/^/$message_prefix /mgr);
}

################################################################################
# command-line options
################################################################################

my %OPTS;

sub parse_opts()
{
	my $rv = GetOptionsFromArray([@ARGV], \%OPTS, "event-id=n", "dry-run!", "debug!", "help!");

	if (!$rv || $OPTS{'help'})
	{
		usage(undef, 0);
	}
}

sub opt($)
{
	my $key = shift;

	return exists($OPTS{$key});
}

sub getopt($)
{
	my $key = shift;

	return exists($OPTS{$key}) ? $OPTS{$key} : undef;
}

sub usage($$)
{
	my $message = shift;
	my $exitval = shift;

	pod2usage(
		-message => $message,
		-exitval => $exitval,
		-verbose => 2,
		-noperldoc,
		-output  => $exitval == 0 ? \*STDOUT : \*STDERR,
	);
}

################################################################################
# database
################################################################################

my $db_handle;

sub is_db_connected()
{
	return defined($db_handle) ? 1 : 0;
}

sub db_connect()
{
	if (defined($db_handle))
	{
		fail("already connected to the database");
	}

	my ($db_host, $db_name, $db_user, $db_pswd, $db_tls_settings) = __get_db_params();

	my $data_source = "DBI:mysql:";

	$data_source .= "host=$db_host;";
	$data_source .= "database=$db_name;";

	$data_source .= "mysql_connect_timeout=30;";
	$data_source .= "mysql_write_timeout=30;";
	$data_source .= "mysql_read_timeout=30;";

	$data_source .= $db_tls_settings;

	my $connect_opts = {
		'PrintError'           => 0,
		'HandleError'          => \&__handle_db_error,
		'mysql_auto_reconnect' => 1,
	};

	$db_handle = DBI->connect($data_source, $db_user, $db_pswd, $connect_opts);

	# verify that established database connection uses TLS if there was any hint that it is required in the config
	unless ($db_tls_settings eq "mysql_ssl=0;")
	{
		my $rows = db_select("show status like 'Ssl_cipher'");

		fail("established connection is not secure") if ($rows->[0][1] eq "");

		dbg("established connection uses \"" . $rows->[0][1] . "\" cipher");
	}
	else
	{
		dbg("established connection is unencrypted");
	}

	# improve performance of selects, see
	# http://search.cpan.org/~capttofu/DBD-mysql-4.028/lib/DBD/mysql.pm
	# for details
	$db_handle->{'mysql_use_result'} = 1;
}

sub db_disconnect()
{
	if (!defined($db_handle))
	{
		wrn("not connected to the database");
		return;
	}

	my @active_handles = ();

	foreach my $handle (@{$db_handle->{'ChildHandles'}})
	{
		if (defined($handle) && $handle->{'Type'} eq 'st' && $handle->{'Active'})
		{
			push(@active_handles, $handle);
		}
	}

	if (@active_handles)
	{
		wrn("called while having " . scalar(@active_handles) . " active statement handle(s)");

		foreach my $handle (@active_handles)
		{
			wrn(__generate_db_error($handle, "active statement"));
			$handle->finish();
		}
	}

	$db_handle->disconnect() or wrn($db_handle->errstr);
	undef($db_handle);
}

sub db_select($;$)
{
	my $query = shift;
	my $bind_values = shift; # optional; reference to an array

	my $sth = $db_handle->prepare($query);

	if (defined($bind_values))
	{
		dbg("[$query] " . join(',', @{$bind_values})) if (log_debug_messages());

		$sth->execute(@{$bind_values});
	}
	else
	{
		dbg("[$query]") if (log_debug_messages());

		$sth->execute();
	}

	my $rows = $sth->fetchall_arrayref();

	if (log_debug_messages())
	{
		if (scalar(@{$rows}) == 1)
		{
			dbg(join(',', map($_ // 'UNDEF', @{$rows->[0]})));
		}
		else
		{
			dbg(scalar(@{$rows}) . " rows");
		}
	}

	return $rows;
}

sub db_select_col($;$)
{
	my $query = shift;
	my $bind_values = shift; # optional; reference to an array

	my $rows = db_select($query, $bind_values);

	fail("query returned more than one column") if (scalar(@{$rows}) > 0 && scalar(@{$rows->[0]}) > 1);

	return [map($_->[0], @{$rows})];
}

sub db_select_row($;$)
{
	my $query = shift;
	my $bind_values = shift; # optional; reference to an array

	my $rows = db_select($query, $bind_values);

	fail("query did not return any row") if (scalar(@{$rows}) == 0);
	fail("query returned more than one row") if (scalar(@{$rows}) > 1);

	return $rows->[0];
}

sub db_select_value($;$)
{
	my $query = shift;
	my $bind_values = shift; # optional; reference to an array

	my $row = db_select_row($query, $bind_values);

	fail("query returned more than one value") if (scalar(@{$row}) > 1);

	return $row->[0];
}

sub db_exec($;$)
{
	my $query = shift;
	my $bind_values = shift; # optional; reference to an array

	my $sth = $db_handle->prepare($query);

	if (defined($bind_values))
	{
		dbg("[$query] " . join(',', @{$bind_values})) if (log_debug_messages());

		$sth->execute(@{$bind_values});
	}
	else
	{
		dbg("[$query]") if (log_debug_messages());

		$sth->execute();
	}

	return $sth->{mysql_insertid};
}

sub __get_db_params()
{
	my $db_host = 'localhost';
	my $db_name = undef;
	my $db_user = '';
	my $db_pswd = '';

	my $db_tls_key_file  = undef;
	my $db_tls_cert_file = undef;
	my $db_tls_ca_file   = undef;
	my $db_tls_ca_path   = undef;
	my $db_tls_cipher    = undef;

	open(my $fh, '<', ZABBIX_SERVER_CONF_FILE) or fail("cannot open ${\ZABBIX_SERVER_CONF_FILE}: $!");

	while (<$fh>)
	{
		if (/^(DB.*)=(.*)$/)
		{
			my $key   = $1;
			my $value = $2;

			$db_host = $value if ($key eq 'DBHost');
			$db_name = $value if ($key eq 'DBName');
			$db_user = $value if ($key eq 'DBUser');
			$db_pswd = $value if ($key eq 'DBPassword');

			$db_tls_key_file  = $value if ($key eq 'DBKeyFile');
			$db_tls_cert_file = $value if ($key eq 'DBCertFile');
			$db_tls_ca_file   = $value if ($key eq 'DBCAFile');
			$db_tls_ca_path   = $value if ($key eq 'DBCAPath');
			$db_tls_cipher    = $value if ($key eq 'DBCipher');
		}
	}

	close($fh) or fail("cannot close ${\ZABBIX_SERVER_CONF_FILE}: $!");

	my $db_tls_settings = "";

	$db_tls_settings .= "mysql_ssl_client_key="  . $db_tls_key_file  . ";" if (defined($db_tls_key_file));
	$db_tls_settings .= "mysql_ssl_client_cert=" . $db_tls_cert_file . ";" if (defined($db_tls_cert_file));
	$db_tls_settings .= "mysql_ssl_ca_file="     . $db_tls_ca_file   . ";" if (defined($db_tls_ca_file));
	$db_tls_settings .= "mysql_ssl_ca_path="     . $db_tls_ca_path   . ";" if (defined($db_tls_ca_path));
	$db_tls_settings .= "mysql_ssl_cipher="      . $db_tls_cipher    . ";" if (defined($db_tls_cipher));

	if ($db_tls_settings)
	{
		$db_tls_settings = "mysql_ssl=1;" . $db_tls_settings;
	}
	else
	{
		$db_tls_settings = "mysql_ssl=0;";
	}

	return $db_host, $db_name, $db_user, $db_pswd, $db_tls_settings;
}

sub __handle_db_error($$$)
{
	my $message = shift;
	my $handle  = shift;

	fail(__generate_db_error($handle, undef));
}

sub __generate_db_error($$)
{
	my $handle  = shift;
	my $message = shift // $handle->errstr;

	my @message_parts = ();

	push(@message_parts, "database error:");

	push(@message_parts, $message);

	if (defined($handle->{'Statement'}))
	{
		push(@message_parts, "(query: [$handle->{'Statement'}])");
	}

	if (defined($handle->{'ParamValues'}) && %{$handle->{'ParamValues'}})
	{
		my $params = join(',', values(%{$handle->{'ParamValues'}}));
		push(@message_parts, "(params: [$params])");
	}

	if (defined($handle->{'ParamArrays'}) && %{$handle->{'ParamArrays'}})
	{
		my $params = join(',', values(%{$handle->{'ParamArrays'}}));
		push(@message_parts, "(params 2: [$params])");
	}

	return join(' ', @message_parts);
}

################################################################################
# end of script
################################################################################

main();

__END__

=head1 NAME

compliance-notification.pl - calls script.py.

=head1 SYNOPSIS

compliance-notification.pl --event-id <event-id> [--dry-run] [--debug] [--help]

=head1 OPTIONS

=over 8

=item B<--event-id> int

Specify year. If year is specified, month also has to be specified.

=item B<--dry-run>

Print data to the screen, do not change anything in the system.

=item B<--debug>

Run the script in debug mode. This means printing more information.

=item B<--help>

Print a brief help message and exit.

=back

=cut
